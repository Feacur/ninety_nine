#include "engine/api/code.h"
#include "engine/api/system.h"
#include "window_internal.h"

#include <signal.h>
#include <Windows.h>

bool engine_system_should_close;

static void signal_handler(int value);
void engine_system_init(void) {
	engine_window_internal_register_class();

	signal(SIGABRT, signal_handler);
	signal(SIGFPE,  signal_handler);
	signal(SIGILL,  signal_handler);
	signal(SIGINT,  signal_handler);
	signal(SIGSEGV, signal_handler);
	signal(SIGTERM, signal_handler);
}

void engine_system_deinit(void) {
	engine_window_internal_unregister_class();
}

void engine_system_poll_events(void) {
	MSG message;
	while (PeekMessageA(&message, 0, 0, 0, PM_REMOVE)) {
		if (message.message == WM_QUIT) { engine_system_should_close = true; continue; }
		TranslateMessage(&message);
		DispatchMessageA(&message);
	}
}

//
//
//

static void signal_handler(int value) {
	// http://www.cplusplus.com/reference/csignal/signal/
	switch (value) {
		case SIGABRT: ENGINE_DEBUG_BREAK(); break; // Abnormal termination, such as is initiated by the abort function.
		case SIGFPE:  ENGINE_DEBUG_BREAK(); break; // Erroneous arithmetic operation, such as zero divide or an operation resulting in overflow (not necessarily with a floating-point operation).
		case SIGILL:  ENGINE_DEBUG_BREAK(); break; // Invalid function image, such as an illegal instruction. This is generally due to a corruption in the code or to an attempt to execute data.
		case SIGINT:  ENGINE_DEBUG_BREAK(); break; // Interactive attention signal. Generally generated by the application user.
		case SIGSEGV: ENGINE_DEBUG_BREAK(); break; // Invalid access to storage: When a program tries to read or write outside the memory it has allocated.
		case SIGTERM: ENGINE_DEBUG_BREAK(); break; // Termination request sent to program.
		default:      ENGINE_DEBUG_BREAK(); break; // ?
	}
	engine_system_should_close = true;
}

// https://docs.microsoft.com/en-us/cpp/c-runtime-library/argc-argv-wargv
// https://docs.microsoft.com/en-us/windows/win32/desktop-programming
// https://docs.microsoft.com/en-us/windows/win32/dlls/dllmain
// https://docs.microsoft.com/en-us/windows/win32/learnwin32/winmain--the-application-entry-point
// https://docs.microsoft.com/en-us/cpp/build/reference/subsystem-specify-subsystem

extern int main(int argc, char * argv[]);
int WINAPI WinMain(
	HINSTANCE hInstance,     // is something called a "handle to an instance" or "handle to a module." The operating system uses this value to identify the executable (EXE) when it is loaded in memory. The instance handle is needed for certain Windows functions—for example, to load icons or bitmaps.
	HINSTANCE hPrevInstance, // has no meaning. It was used in 16-bit Windows, but is now always zero.
	PSTR      pCmdLine,      // contains the command-line arguments as an ANSI string.
	int       nCmdShow       // is a flag that says whether the main application window will be minimized, maximized, or shown normally.
) {
	(void)hInstance; (void)hPrevInstance; (void)pCmdLine; (void)nCmdShow;
	return main(__argc, __argv);
}

//
//
//

#if defined(__clang__)
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wmissing-variable-declarations"
#endif

// http://developer.download.nvidia.com/devzone/devcenter/gamegraphics/files/OptimusRenderingPolicies.pdf
// Global Variable NvOptimusEnablement (new in Driver Release 302)
// Starting with the Release 302 drivers, application developers can direct the Optimus driver at runtime to use the High Performance Graphics to render any application–even those applications for which there is no existing application profile. They can do this by exporting a global variable named NvOptimusEnablement. The Optimus driver looks for the existence and value of the export. Only the LSB of the DWORD matters at this time. Avalue of 0x00000001 indicates that rendering should be performed using High Performance Graphics. A value of 0x00000000 indicates that this method should beignored.
__declspec(dllexport) DWORD NvOptimusEnablement = 0x00000001UL;

// https://community.amd.com/thread/169965
// https://community.amd.com/thread/223376
// https://gpuopen.com/amdpowerxpressrequesthighperformance/
// Many Gaming and workstation laptops are available with both (1) integrated power saving and (2) discrete high performance graphics devices. Unfortunately, 3D intensive application performance may suffer greatly if the best graphics device is not selected. For example, a game may run at 30 Frames Per Second (FPS) on the integrated GPU rather than the 60 FPS the discrete GPU would enable. As a developer you can easily fix this problem by adding only one line to your executable’s source code:
__declspec(dllexport) DWORD AmdPowerXpressRequestHighPerformance = 0x00000001UL;
// Yes, it’s that easy. This line will ensure that the high-performance graphics device is chosen when running your application.

#if defined(__clang__)
#pragma clang diagnostic pop
#endif
